## 2. The Module System (Deepest Dive)

The module system is the cornerstone of SDR++CE's extensibility. It allows functionality to be added or removed simply by adding or removing files from a directory, without recompiling the core application. This document provides a detailed guide for developers looking to create new modules.

### 2.1. Module ABI and Lifecycle Explained

All modules are dynamic libraries that expose a standard C ABI (Application Binary Interface). This is crucial for stability, as it avoids C++ name mangling issues and ensures that modules compiled with different compiler versions can be safely loaded.

**The SDRPP_MOD_INFO Macro:**

Every module must begin with the `SDRPP_MOD_INFO` macro, which defines the module metadata:

```cpp
SDRPP_MOD_INFO{
    /* Name:            */ "my_module",
    /* Description:     */ "My custom module for SDR++CE",
    /* Author:          */ "Your Name",
    /* Version:         */ 1, 0, 0,  // Major, Minor, Build
    /* Max instances    */ 1          // -1 for unlimited
};
```

This macro automatically generates the required exported symbols. You must also implement:

```cpp
// Module initialization
MOD_EXPORT void _INIT_() {
    // One-time module setup (optional)
}

// Instance factory
MOD_EXPORT ModuleManager::Instance* _CREATE_INSTANCE_(std::string name) {
    return new MyModule(name);
}

// Instance destructor  
MOD_EXPORT void _DELETE_INSTANCE_(ModuleManager::Instance* instance) {
    delete instance;
}

// Module cleanup
MOD_EXPORT void _END_() {
    // One-time module cleanup (optional)
}
```

**Required Exported Symbols (Generated by SDRPP_MOD_INFO):**

| Symbol             | Signature                                                 | Description                                                                                             |
| ------------------ | --------------------------------------------------------- | ------------------------------------------------------------------------------------------------------- |
| `_INFO_`           | `const ModuleManager::ModuleInfo_t`                       | **Metadata.** A struct containing the module's name, description, author, version, and max instances. The name is used as a key in the `ModuleManager`. |
| `_INIT_`           | `void()`                                                  | **One-Time Setup.** Called *once* when the module library is first loaded. Use for setup that is not instance-specific. |
| `_CREATE_INSTANCE_` | `ModuleManager::Instance* (std::string name)`             | **Factory Function.** Called by the core to create a new instance of the module's primary class. Must return a `new` object. |
| `_DELETE_INSTANCE_` | `void (ModuleManager::Instance* instance)`                | **Destructor.** Called by the core to destroy an instance. Must `delete` the provided instance pointer. |
| `_END_`            | `void()`                                                  | **One-Time Teardown.** Called once just before the module library is unloaded. Use for global cleanup. |

**The `ModuleManager::Instance` Interface:**

Every module's main class must inherit from `ModuleManager::Instance` and implement its pure virtual methods. This interface defines the lifecycle of a module *instance*.

```cpp
class ModuleManager::Instance {
public:
    virtual ~Instance() {}
    virtual void postInit() = 0; // The primary integration point.
    virtual void enable() = 0;     // Activates the module's main functionality.
    virtual void disable() = 0;    // Deactivates the module's main functionality.
    virtual bool isEnabled() = 0;  // Returns the current enabled state.
};
```

*   **`postInit()`:** This is the most important lifecycle method. It's called after **all** module instances specified in the config have been created. This guarantees that when your module's `postInit` is called, you can safely communicate with other modules or register with core systems, knowing they exist.
*   **`enable()`/`disable()`:** These methods typically flip an internal `enabled` boolean. For modules that have an ongoing background task (like a source module), `enable` should start the task/thread, and `disable` should stop it.

### 2.2. API and Patterns for Each Module Type

#### 2.2.1. Source Module (Developer Guide)

*   **Goal:** Provide an IQ stream to the `IQFrontEnd`.
*   **Class Structure:**
    ```cpp
    #include <module.h>
    #include <signal_path/signal_path.h>
    #include <core.h>

    class MySourceModule : public ModuleManager::Instance {
    public:
        MySourceModule(std::string name) {
            this->name = name;
            
            // Set up the handler structure with function pointers
            handler.ctx = this;
            handler.selectHandler = menuSelected;
            handler.deselectHandler = menuDeselected;
            handler.menuHandler = menuHandler;
            handler.startHandler = start;
            handler.stopHandler = stop;
            handler.tuneHandler = tune;
            handler.gainHandler = setGain;  // Can be NULL if not supported
            handler.stream = &stream;
            
            // Register in constructor, not postInit!
            sigpath::sourceManager.registerSource("My Custom Source", &handler);
        }
        
        ~MySourceModule() {
            stop(this);
            sigpath::sourceManager.unregisterSource("My Custom Source");
        }

        // --- ModuleManager::Instance Implementation ---
        void postInit() override { /* Usually empty for source modules */ }
        void enable() override { enabled = true; }
        void disable() override { enabled = false; }
        bool isEnabled() override { return enabled; }

        // --- SourceManager Handler Functions (static) ---
        static void menuSelected(void* ctx) {
            MySourceModule* _this = (MySourceModule*)ctx;
            // Called when source is selected in UI
            core::setInputSampleRate(_this->sampleRate);
            // Additional setup...
        }
        
        static void start(void* ctx) {
            MySourceModule* _this = (MySourceModule*)ctx;
            if (_this->running) return;
            _this->running = true;
            _this->workerThread = std::thread(worker, _this);
        }
        
        static void stop(void* ctx) {
            MySourceModule* _this = (MySourceModule*)ctx;
            if (!_this->running) return;
            _this->stream.stopWriter();
            _this->workerThread.join();
            _this->stream.clearWriteStop();
            _this->running = false;
        }
        
        static void tune(double freq, void* ctx) {
            MySourceModule* _this = (MySourceModule*)ctx;
            _this->freq = freq;  // Use atomics for thread safety
        }
        
        static void menuHandler(void* ctx) {
            MySourceModule* _this = (MySourceModule*)ctx;
            // Render ImGui controls for source configuration
        }

    private:
        static void worker(void* ctx) {
            MySourceModule* _this = (MySourceModule*)ctx;
            // Loop that reads from hardware/network
            // and calls: _this->stream.write(iq_data, count);
        }
        
        std::string name;
        bool enabled = true;
        bool running = false;
        dsp::stream<dsp::complex_t> stream;
        SourceManager::SourceHandler handler;
        std::thread workerThread;
        double sampleRate = 1000000;
        double freq = 100000000;
    };
    ```
*   **Key Responsibilities:**
    *   **DO NOT inherit from any Source interface** - source modules use a handler-based pattern
    *   Create a `SourceManager::SourceHandler` structure with function pointers to static methods
    *   Register with `sigpath::sourceManager.registerSource()` in the **constructor**, not postInit
    *   Implement static handler functions that receive a void* context pointer
    *   The `handler.stream` must point to your output stream
    *   Unregister in the destructor to prevent crashes on unload

#### 2.2.2. Decoder Module (Developer Guide)

*   **Goal:** Provide a `dsp::hier_block` that can demodulate a VFO's IQ stream into an audio stream.
*   **Class Structure (Factory):** You don't register the module itself, but a factory object.
    ```cpp
    // The DSP block for your demodulator
    class MyDemodulator : public dsp::hier_block<dsp::complex_t, dsp::stereo_t> {
        // ... internal DSP blocks and streams to perform demodulation ...
    };

    // The factory that creates the demodulator
    class MyDemodulatorFactory {
    public:
        dsp::hier_block<dsp::complex_t, dsp::stereo_t>* create(double sampleRate, int vfoId) {
            return new MyDemodulator(sampleRate, vfoId);
        }
    };

    // In your main module class (inherits from ModuleManager::Instance)
    class MyRadioModule : public ModuleManager::Instance {
    public:
        void postInit() override {
            // Register the factory with the VFOManager
            core::vfoManager.registerDemodulator("MYDEMOD", &factory);
        }
        // ... other methods ...
    private:
        MyDemodulatorFactory factory;
    };
    ```
*   **Key Responsibilities:**
    *   Create a class that inherits from `dsp::hier_block<dsp::complex_t, dsp::stereo_t>`. This class will contain the actual DSP logic.
    *   Create a simple factory class with a `create` method that allocates and returns an instance of your demodulator block.
    *   In your main module's `postInit`, register an instance of your factory with `core::vfoManager.registerDemodulator`.

#### 2.2.3. Sink Module (Developer Guide)

*   **Goal:** Consume the final audio stream from the `SignalPath`.
*   **Architecture:** Sink modules use a provider pattern where the module registers a factory function, not a sink instance.
*   **Class Structure:**
    ```cpp
    #include <module.h>
    #include <signal_path/sink.h>
    #include <signal_path/signal_path.h>
    #include <dsp/buffer/packer.h>

    class AudioSink : SinkManager::Sink {
    public:
        AudioSink(SinkManager::Stream* stream, std::string streamName) {
            _stream = stream;
            _streamName = streamName;
            
            // Initialize DSP chain
            stereoPacker.init(_stream->sinkOut, 512);
            
            // Initialize audio device, etc.
        }
        
        ~AudioSink() {
            stop();
        }

        // --- SinkManager::Sink Implementation ---
        void start() override {
            if (running) return;
            // Start audio device/thread
            running = true;
        }
        
        void stop() override {
            if (!running) return;
            // Stop audio device/thread
            running = false;
        }
        
        void menuHandler() override {
            // Render ImGui controls for sink configuration
            // Device selection, sample rate, etc.
        }

    private:
        SinkManager::Stream* _stream;
        std::string _streamName;
        dsp::buffer::Packer<dsp::stereo_t> stereoPacker;
        bool running = false;
    };

    class AudioSinkModule : public ModuleManager::Instance {
    public:
        AudioSinkModule(std::string name) {
            this->name = name;
            
            // Create the sink provider
            provider.create = createSink;
            provider.ctx = this;
            
            // Register as a sink provider
            sigpath::sinkManager.registerSinkProvider("Audio", provider);
        }
        
        ~AudioSinkModule() {
            sigpath::sinkManager.unregisterSinkProvider("Audio");
        }

        void postInit() override { /* Empty */ }
        void enable() override { enabled = true; }
        void disable() override { enabled = false; }
        bool isEnabled() override { return enabled; }

    private:
        static SinkManager::Sink* createSink(SinkManager::Stream* stream, 
                                           std::string streamName, void* ctx) {
            // This factory function is called when a stream selects this sink
            return new AudioSink(stream, streamName);
        }
        
        std::string name;
        bool enabled = true;
        SinkManager::SinkProvider provider;
    };
    ```
*   **Key Responsibilities:**
    *   Create a class that inherits from `SinkManager::Sink` (NOT ModuleManager::Instance)
    *   The main module class registers a `SinkProvider` with a factory function
    *   The factory function creates sink instances when streams need them
    *   Each sink instance receives a `SinkManager::Stream*` which contains:
        *   `stream->sinkOut`: The dsp::stream to read audio data from
        *   Stream management methods
    *   The sink is responsible for consuming audio from `stream->sinkOut`
    *   Registration happens in constructor with `sigpath::sinkManager.registerSinkProvider()`

### 2.3. Common Patterns and Best Practices

#### 2.3.1. Configuration Management

Most modules need to persist settings. The pattern is to create a module-specific ConfigManager:

```cpp
ConfigManager config;  // Module-level global

class MyModule : public ModuleManager::Instance {
    MyModule(std::string name) {
        this->name = name;
        
        // Initialize config with defaults
        config.acquire();
        if (!config.conf.contains(name)) {
            config.conf[name]["setting1"] = "default";
            config.conf[name]["setting2"] = 42;
        }
        loadedSetting = config.conf[name]["setting1"];
        config.release();
    }
    
    void menuHandler() {
        if (ImGui::InputText("Setting", &loadedSetting)) {
            config.acquire();
            config.conf[name]["setting1"] = loadedSetting;
            config.release(true);  // true = modified
        }
    }
};
```

#### 2.3.2. Thread Safety

- Use `std::atomic` for simple values accessed across threads
- Static handler functions receive `void* ctx` - cast back to your class
- The DSP thread must never block on the UI thread
- Use `dsp::stream::stopWriter()` for clean shutdown

#### 2.3.3. Registration Timing

- **Source modules**: Register in constructor, unregister in destructor
- **Sink modules**: Register provider in constructor
- **Decoder modules**: Register in postInit() when other systems are ready
- **Misc modules**: Register menu entries in constructor or postInit()

#### 2.3.4. Error Handling

- Check if resources exist before using them
- Handle module absence gracefully (e.g., frequency manager might not be loaded)
- Log errors with `flog::error()` but don't crash
- Clean up resources in destructors even if init failed

#### 2.3.5. Module CMake Setup

```cmake
file(GLOB SRC "src/*.cpp")
add_library(my_module SHARED ${SRC})
target_link_libraries(my_module PRIVATE sdrpp_core)
set_target_properties(my_module PROPERTIES PREFIX "")

# Install to correct location
if (MSVC)
    install(TARGETS my_module DESTINATION modules)
else()
    install(TARGETS my_module DESTINATION lib/sdrpp/plugins)
endif()
```

*For a deeper dive into advanced module patterns and inter-module communication, see the [Module Internals](./02a_module_internals.md) document.*
